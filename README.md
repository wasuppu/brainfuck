# brainfuck

I first came across [this](https://github.com/pablojorge/brainfuck) collection of Brainfuck implementations at the end of the 
article [Hello, JIT World: The Joy of Simple JITs](https://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html). 
I referenced [brainfuck.go](https://github.com/pablojorge/brainfuck/blob/master/go/brainfuck.go) and 
[bf2c.hs](https://github.com/pablojorge/brainfuck/blob/master/haskell/bf2c.hs) to write the initial version and the C code generation variant.

I then modified the Brainfuck interpreter based on this video [Making a Brainf*** JIT Compiler in Rust!](https://www.youtube.com/watch?v=3aRdIijtGrM),
following its steps to incrementally improve performance. The video's code repository [bf-jit-rs](https://github.com/soirihiroka/bf-jit-rs/) uses 
[dynasmrt](https://docs.rs/dynasmrt/latest/dynasmrt/) to generate machine code using for JIT, I couldn't find a equivalent tool in Go, 
so I referenced tscoding's video [Making a Brainf*** JIT Compiler in Rust!](https://www.youtube.com/watch?v=3aRdIijtGrM) to made a JIT version 
for Brainfuck based one interp4. However, the generated code from tscoding's video couldn't be directly worded in my code. 
I have almost zero knowledge of assembly. With AI assistance, I managed to make it work. The assembly version was also generated by AI based on the C version.

# Usage

You can run the generated assembly and C versions using the following command. Other ‌implementation‌s only require providing a bf file to run directly.

```
# asm
go run ./asm exmaples/mandelbrot.b > mandelbrot.s
gcc -static -o bandelbrot mandelbrot.s
./bandelbrot
# c
go run ./c exmaples/mandelbrot.b > mandelbrot.c
gcc mandelbrot.c -o mandelbrot
./bandelbrot
```

# Benchmarks

Ran the mandelbrot.b file on my local machine using time.

| version | runtime |
|-|-|
| interp1 | 49.20s |
| interp2 | 48.20s |
| interp3 | 34.22s |
| interp4 | 13.07s |
| interp5 | 14.33s |
| jit | 2.90s |
| c | 31.70s |
| asm | 4.04s |

